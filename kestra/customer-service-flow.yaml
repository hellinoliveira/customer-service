id: pedalandoali-customer-service
namespace: pedalandoali
description: |
  Customer Service Automation for Pedalando Ali
  Handles incoming WhatsApp messages, displays menus, and routes users
  Updated for Kestra v1.1.0+

labels:
  env: production
  team: customer-service

pluginDefaults:
  - type: io.kestra.plugin.scripts.python.Script
    values:
      taskRunner:
        type: io.kestra.plugin.scripts.runner.docker.Docker
        networkMode: customer-service_pedalando_net

inputs:
  - id: webhook_payload
    type: JSON
    description: Incoming webhook payload from Evolution API (optional - used only for manual testing)
    required: false

variables:
  # Evolution API Configuration (secrets resolved at runtime)
  INSTANCE_NAME: "pedalandoali"

  # Internal notification number (attendant)
  ATTENDANT_PHONE: "5562998610696"

  # Promo Group Links
  LINK_CYCLING: "https://chat.whatsapp.com/E7oE5EiBefmG5n3JykAYb5"
  LINK_HOME: "https://chat.whatsapp.com/LYRM0eDNRtgCmSkk033g6w"
  LINK_FASHION: "https://chat.whatsapp.com/JF7mfPnBstxANb4ixMssza"
  LINK_AUTOMOTIVE: "https://chat.whatsapp.com/DF85Zgr5GF9AkcC5OuWpHU"
  LINK_RUNNING: "https://chat.whatsapp.com/FOyM06ACufo2atIisM28Hf"
  CATALOG_URL: "https://wa.me/c/556282165694"

  # State TTL (30 minutes)
  STATE_TTL_SECONDS: 1800
  # Attendant Mode TTL (24 hours)
  ATTENDANT_TTL_SECONDS: 86400

triggers:
  - id: webhook_trigger
    type: io.kestra.plugin.core.trigger.Webhook
    key: "pedalandoali-cs-webhook"
    conditions:
      - type: io.kestra.plugin.core.condition.Expression
        expression: "{{ trigger.body.event == 'messages.upsert' }}"

tasks:
  # ============================================================
  # TASK 1: Process Incoming Message (Parse + State + Map)
  # ============================================================
  - id: process_incoming
    type: io.kestra.plugin.scripts.python.Script
    containerImage: python:3.11-slim
    beforeCommands:
      - pip install kestra redis
    env:
      REDIS_HOST: "{{ secret('REDIS_HOST') }}"
      REDIS_PORT: "{{ secret('REDIS_PORT') }}"
      REDIS_PASSWORD: "{{ secret('REDIS_PASSWORD') }}"
      ATTENDANT_TTL_SECONDS: "{{ vars.ATTENDANT_TTL_SECONDS }}"
      STATE_TTL_SECONDS: "{{ vars.STATE_TTL_SECONDS }}"
    script: |
      import json
      import os
      import redis
      from datetime import datetime
      from kestra import Kestra

      # --- 1. Parse Message ---
      payload = json.loads('''{% if trigger is defined %}{{ trigger.body | json }}{% else %}{{ inputs.webhook_payload | json }}{% endif %}''')
      message_data = payload.get('data', {})
      key = message_data.get('key', {})
      message = message_data.get('message', {})
      push_name = message_data.get('pushName', 'Cliente')
      remote_jid = key.get('remoteJid', '')
      sender_phone = remote_jid.replace('@s.whatsapp.net', '') # type: ignore

      message_text = ''
      selected_option = ''

      if 'conversation' in message:
          message_text = message['conversation']
      elif 'extendedTextMessage' in message:
          message_text = message['extendedTextMessage'].get('text', '')
      elif 'listResponseMessage' in message:
          selected_option = message['listResponseMessage'].get('singleSelectReply', {}).get('selectedRowId', '')
          message_text = message['listResponseMessage'].get('title', '')
      elif 'buttonsResponseMessage' in message:
          selected_option = message['buttonsResponseMessage'].get('selectedButtonId', '')
          message_text = message['buttonsResponseMessage'].get('selectedDisplayText', '')

      from_me = key.get('fromMe', False)
      is_group = '@g.us' in remote_jid

      # Skip groups immediately
      if is_group:
          print(f"Skipping group message: {remote_jid}")
          Kestra.outputs({'skip': 'true', 'sender_phone': sender_phone, 'push_name': push_name, 'current_menu': 'SKIP'})
          exit(0)

      # --- 2. Get User State ---
      r = redis.Redis(
          host=os.environ['REDIS_HOST'],
          port=int(os.environ['REDIS_PORT']),
          password=os.environ['REDIS_PASSWORD'],
          decode_responses=True
      )

      state_key = f"cs:state:{sender_phone}"
      lock_key = f"cs:lock:{sender_phone}"

      # --- Acquire lock to prevent race conditions ---
      # If another message from this user is being processed, skip this one
      lock_acquired = r.set(lock_key, "1", nx=True, ex=30)
      if not lock_acquired:
          print(f"Skipping: another message from {sender_phone} is being processed")
          Kestra.outputs({'skip': 'true', 'sender_phone': sender_phone, 'push_name': push_name, 'current_menu': 'LOCKED'})
          exit(0)

      state_data = r.get(state_key)

      if state_data:
          state = json.loads(state_data)
          current_menu = state.get('current_menu', 'NONE')
      else:
          current_menu = 'NONE'

      # --- 3. Handle "YOU initiated conversation" scenario ---
      if from_me and current_menu == 'NONE':
          # You sent a message to someone with no state = You're initiating contact
          # Set them to ATTENDANT mode for 24h
          attendant_ttl = int(os.environ.get('ATTENDANT_TTL_SECONDS', '86400'))
          state = {
              'current_menu': 'ATTENDANT',
              'push_name': push_name,
              'last_interaction': datetime.now().isoformat()
          }
          r.setex(state_key, attendant_ttl, json.dumps(state))
          print(f"You initiated conversation with {sender_phone} - set to ATTENDANT mode (24h)")
          Kestra.outputs({'skip': 'true', 'sender_phone': sender_phone, 'push_name': push_name, 'current_menu': 'ATTENDANT'})
          exit(0)

      # Skip messages from self (after checking initiation)
      if from_me:
          print("Skipping: message from self")
          Kestra.outputs({'skip': 'true', 'sender_phone': sender_phone, 'push_name': push_name, 'current_menu': 'SKIP'})
          exit(0)

      # --- 3. Map Selection ---
      final_selection = ""
      msg = message_text.strip() # type: ignore

      if selected_option:
          final_selection = selected_option
      elif current_menu == 'ATTENDANT':
          # Refresh TTL to keep conversation open
          attendant_ttl = int(os.environ.get('ATTENDANT_TTL_SECONDS', '86400'))
          r.expire(state_key, attendant_ttl)
          final_selection = 'SKIP'
      elif current_menu == 'NONE':
          # New user - set state immediately to prevent race condition
          state_ttl = int(os.environ.get('STATE_TTL_SECONDS', '1800'))
          state = {
              'current_menu': 'MAIN_MENU',
              'push_name': push_name,
              'last_interaction': datetime.now().isoformat()
          }
          r.setex(state_key, state_ttl, json.dumps(state))
          print(f"New user {sender_phone} - state set to MAIN_MENU")
          final_selection = 'NEW_USER'
      else:
          if current_menu == 'MAIN_MENU':
              if msg == '1':
                  final_selection = 'PROMO_GROUPS'
              elif msg == '2':
                  final_selection = 'CATALOG'
              else:
                  # Any message other than "1" or "2" goes to attendant (silent handoff)
                  final_selection = 'ATTENDANT'

      # Release lock
      r.delete(lock_key)

      # --- Output All Data ---
      Kestra.outputs({
          'skip': 'false',
          'sender_phone': sender_phone,
          'push_name': push_name,
          'message_text': message_text.strip().lower(), # type: ignore
          'timestamp': datetime.now().isoformat(),
          'current_menu': current_menu,
          'final_selection': final_selection
      })

  # ============================================================
  # TASK 2: Debug Print (only if not skipped)
  # ============================================================
  - id: debug_values
    type: io.kestra.plugin.core.flow.If
    condition: "{{ outputs.process_incoming.vars.skip == 'false' }}"
    then:
      - id: log_debug_info
        type: io.kestra.plugin.core.log.Log
        message: "Menu: {{ outputs.process_incoming.vars.current_menu }}, Text: {{ outputs.process_incoming.vars.message_text }}, Selection: {{ outputs.process_incoming.vars.final_selection }}"


  # ============================================================
  # TASK 4: Route Based on State and Selection
  # ============================================================
  - id: should_process_message
    type: io.kestra.plugin.core.flow.If
    condition: "{{ outputs.process_incoming.vars.skip == 'false' and outputs.process_incoming.vars.current_menu != 'ATTENDANT' }}"
    then:
      - id: route_message
        type: io.kestra.plugin.core.flow.Switch
        value: "{{ outputs.process_incoming.vars.current_menu | default('NONE') }}_{{ outputs.process_incoming.vars.final_selection | default('') }}"

        cases:
          # ---------------------------------------------------------
          # CASE: New user - Send Main Menu (state already set in process_incoming)
          # ---------------------------------------------------------
          NONE_NEW_USER:
            - id: send_main_menu
              type: io.kestra.plugin.core.http.Request
              uri: "{{ secret('EVOLUTION_API_URL') }}/message/sendText/{{ vars.INSTANCE_NAME }}"
              method: POST
              headers:
                Content-Type: application/json
                apikey: "{{ secret('EVOLUTION_API_KEY') }}"
              body: |
                {
                  "number": "{{ outputs.process_incoming.vars.sender_phone }}",
                  "delay": 1200,
                  "text": "Ol√°, {{ outputs.process_incoming.vars.push_name }}! üëã\n\nSeja bem vindo ao PedalandoAli! üö¥‚Äç‚ôÇÔ∏è\n\nSomos especialistas em encontrar as melhores ofertas para voc√™.\n\nüéØ *Grupos de Promo√ß√µes*\n   Responda *1* para receber os links\n\nüì¶ *Cat√°logo de Produtos*\n   Responda *2* para ver nosso cat√°logo de produtos de ciclismo\n\nüí¨ *Precisa de Ajuda?*\n   Digite sua d√∫vida que um atendente ir√° responder"
                }

          # ---------------------------------------------------------
          # CASE: User message goes to attendant (silent handoff)
          # ---------------------------------------------------------
          MAIN_MENU_ATTENDANT:
            - id: set_state_attendant
              type: io.kestra.plugin.scripts.python.Script
              containerImage: python:3.11-slim
              beforeCommands:
                - pip install redis
              env:
                REDIS_HOST: "{{ secret('REDIS_HOST') }}"
                REDIS_PORT: "{{ secret('REDIS_PORT') }}"
                REDIS_PASSWORD: "{{ secret('REDIS_PASSWORD') }}"
                ATTENDANT_TTL: "{{ vars.ATTENDANT_TTL_SECONDS }}"
              script: |
                import redis
                import json
                import os

                sender_phone = "{{ outputs.process_incoming.vars.sender_phone }}"
                push_name = "{{ outputs.process_incoming.vars.push_name }}"

                r = redis.Redis(
                    host=os.environ['REDIS_HOST'],
                    port=int(os.environ['REDIS_PORT']),
                    password=os.environ['REDIS_PASSWORD'],
                    decode_responses=True
                )

                state = {
                    'current_menu': 'ATTENDANT',
                    'push_name': push_name,
                    'last_interaction': "{{ outputs.process_incoming.vars.timestamp }}"
                }

                r.setex(
                    f"cs:state:{sender_phone}",
                    int(os.environ['ATTENDANT_TTL']),
                    json.dumps(state)
                )

          # ---------------------------------------------------------
          # CASE: User selected "Grupos de Promo√ß√µes"
          # ---------------------------------------------------------
          MAIN_MENU_PROMO_GROUPS:
            - id: send_all_groups
              type: io.kestra.plugin.core.http.Request
              uri: "{{ secret('EVOLUTION_API_URL') }}/message/sendText/{{ vars.INSTANCE_NAME }}"
              method: POST
              headers:
                Content-Type: application/json
                apikey: "{{ secret('EVOLUTION_API_KEY') }}"
              body: |
                {
                  "number": "{{ outputs.process_incoming.vars.sender_phone }}",
                  "delay": 1200,
                  "text": "Massa! üéØ\n\nTemos grupos exclusivos para cada estilo. Escolha o seu e receba as melhores ofertas direto no WhatsApp:\n\n1Ô∏è‚É£ *Ciclismo*\n   _Bikes, pe√ßas, acess√≥rios e vestu√°rio_\n   üîó {{ vars.LINK_CYCLING }}\n\n2Ô∏è‚É£ *Casa*\n   _Decora√ß√£o, eletroport√°teis e utilidades_\n   üîó {{ vars.LINK_HOME }}\n\n3Ô∏è‚É£ *Moda e Beleza*\n   _Roupas, cal√ßados e cosm√©ticos_\n   üîó {{ vars.LINK_FASHION }}\n\n4Ô∏è‚É£ *Automotivo*\n   _Acess√≥rios, pe√ßas e ferramentas_\n   üîó {{ vars.LINK_AUTOMOTIVE }}\n\n5Ô∏è‚É£ *Corrida e Fitness*\n   _T√™nis, roupas e equipamentos_\n   üîó {{ vars.LINK_RUNNING }}"
                }
            - id: clear_state_promo
              type: io.kestra.plugin.scripts.python.Script
              containerImage: python:3.11-slim
              beforeCommands:
                - pip install redis
              env:
                REDIS_HOST: "{{ secret('REDIS_HOST') }}"
                REDIS_PORT: "{{ secret('REDIS_PORT') }}"
                REDIS_PASSWORD: "{{ secret('REDIS_PASSWORD') }}"
              script: |
                import redis
                import os
                sender_phone = "{{ outputs.process_incoming.vars.sender_phone }}"
                r = redis.Redis(host=os.environ['REDIS_HOST'], port=int(os.environ['REDIS_PORT']), password=os.environ['REDIS_PASSWORD'], decode_responses=True)
                r.delete(f"cs:state:{sender_phone}")

          # ---------------------------------------------------------
          # CASE: User selected "Cat√°logo"
          # ---------------------------------------------------------
          MAIN_MENU_CATALOG:
            - id: send_catalog
              type: io.kestra.plugin.core.http.Request
              uri: "{{ secret('EVOLUTION_API_URL') }}/message/sendText/{{ vars.INSTANCE_NAME }}"
              method: POST
              headers:
                Content-Type: application/json
                apikey: "{{ secret('EVOLUTION_API_KEY') }}"
              body: |
                {
                  "number": "{{ outputs.process_incoming.vars.sender_phone }}",
                  "delay": 1200,
                  "text": "üì¶ *Cat√°logo de Produtos*\n\nAcesse nosso cat√°logo completo com todas as ofertas:\n\nüîó {{ vars.CATALOG_URL }}\n\nQualquer d√∫vida √© s√≥ chamar! üòâ"
                }
            - id: clear_state_catalog
              type: io.kestra.plugin.scripts.python.Script
              containerImage: python:3.11-slim
              beforeCommands:
                - pip install redis
              env:
                REDIS_HOST: "{{ secret('REDIS_HOST') }}"
                REDIS_PORT: "{{ secret('REDIS_PORT') }}"
                REDIS_PASSWORD: "{{ secret('REDIS_PASSWORD') }}"
              script: |
                import redis
                import os
                sender_phone = "{{ outputs.process_incoming.vars.sender_phone }}"
                r = redis.Redis(host=os.environ['REDIS_HOST'], port=int(os.environ['REDIS_PORT']), password=os.environ['REDIS_PASSWORD'], decode_responses=True)
                r.delete(f"cs:state:{sender_phone}")

        # ---------------------------------------------------------
        # DEFAULT: Any text message resets to main menu
        # ---------------------------------------------------------
        defaults:
          - id: handle_unknown_or_reset
            type: io.kestra.plugin.core.http.Request
            uri: "{{ secret('EVOLUTION_API_URL') }}/message/sendText/{{ vars.INSTANCE_NAME }}"
            method: POST
            headers:
              Content-Type: application/json
              apikey: "{{ secret('EVOLUTION_API_KEY') }}"
            body: |
              {
                "number": "{{ outputs.process_incoming.vars.sender_phone }}",
                "delay": 1200,
                "text": "Ol√°, {{ outputs.process_incoming.vars.push_name }}! üëã\n\nSeja bem-vindo √† Pedalando Ali! üö¥‚Äç‚ôÇÔ∏è\n\nSomos especialistas em encontrar as melhores ofertas para voc√™.\n\nüéØ *Acesse nossos Grupos de Promo√ß√µes*\n   Responda *1* para receber os links\n\nüí¨ *Precisa de Ajuda?*\n   Digite sua d√∫vida que um atendente ir√° responder"
              }
          - id: reset_state_to_main
            type: io.kestra.plugin.scripts.python.Script
            containerImage: python:3.11-slim
            beforeCommands:
              - pip install redis
            env:
              REDIS_HOST: "{{ secret('REDIS_HOST') }}"
              REDIS_PORT: "{{ secret('REDIS_PORT') }}"
              REDIS_PASSWORD: "{{ secret('REDIS_PASSWORD') }}"
              STATE_TTL: "{{ vars.STATE_TTL_SECONDS }}"
            script: |
              import redis
              import json
              import os

              sender_phone = "{{ outputs.process_incoming.vars.sender_phone }}"
              push_name = "{{ outputs.process_incoming.vars.push_name }}"

              r = redis.Redis(
                  host=os.environ['REDIS_HOST'],
                  port=int(os.environ['REDIS_PORT']),
                  password=os.environ['REDIS_PASSWORD'],
                  decode_responses=True
              )

              state = {
                  'current_menu': 'MAIN_MENU',
                  'push_name': push_name,
                  'last_interaction': "{{ outputs.process_incoming.vars.timestamp }}"
              }

              r.setex(
                  f"cs:state:{sender_phone}",
                  int(os.environ['STATE_TTL']),
                  json.dumps(state)
              )
    else:
      - id: log_attendant_mode_skip
        type: io.kestra.plugin.core.log.Log
        message: "Skipping bot response - user {{ outputs.process_incoming.vars.sender_phone }} is in ATTENDANT mode (human takeover)"

errors:
  - id: error_handler
    type: io.kestra.plugin.core.log.Log
    message: "Error in customer service flow. Execution ID: {{ execution.id }}"
